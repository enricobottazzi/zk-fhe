use std::env::var;
use std::vec;

use clap::Parser;
use halo2_base::gates::GateChip;
use halo2_base::safe_types::RangeChip;
use halo2_base::safe_types::RangeInstructions;
use halo2_base::utils::ScalarField;
use halo2_base::AssignedValue;
use halo2_base::Context;
use halo2_base::QuantumCell::Constant;
use halo2_scaffold::scaffold::cmd::Cli;
use halo2_scaffold::scaffold::run;
use serde::{Deserialize, Serialize};
use zk_fhe::chips::distribution::{
    check_poly_from_distribution_chi_error, check_poly_from_distribution_chi_key,
};
use zk_fhe::chips::poly_operations::{poly_add, poly_mul, poly_scalar_mul};

/// Circuit inputs for BFV encryption operations
///
/// # Type Parameters
///
/// * `N`: Degree of the cyclotomic polynomial `cyclo` of the polynomial ring R_q.
/// * `Q`: Modulus of the cipher text field
/// * `T`: Modulus of the plaintext field
/// * `DELTA` : Q/T rounded to the lower integer
/// * `B`: Upper bound of the Gaussian distribution Chi Error. It is defined as 6 * sigma
///
/// # Fields
///
/// * `pk0`: Public key 0 polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i
/// * `pk1`: Public key 1 polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i
/// * `m`: Plaintext polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Represents the message to be encrypted
/// * `u`: Ephemeral key polynomial coefficients from the distribution ChiKey [a_0, a_1, ..., a_N-1]
/// * `e0`: Error polynomial coefficients from the distribution ChiError [a_0, a_1, ..., a_N-1]
/// * `e1`: Error polynomial coefficients from the distribution ChiError [a_0, a_1, ..., a_N-1]

///
/// # Assumes that the following checks have been performed outside the circuit
/// - `N` must be a power of 2
/// - `Q` must be a prime number
/// - `Q` must be greater than 1.
/// -  If n is the number of bits of Q, and m is the number of bits of the prime field of the circuit. n must be set such that (n * 2) + 2 < m to avoid overflow of the coefficients of the polynomials
/// - `T` must be a prime number and must be greater than 1 and less than `Q`
/// - `B` must be a positive integer
/// - `pk0` and `pk1` must be polynomials in the R_q ring. The ring R_q is defined as R_q = Z_q[x]/(x^N + 1)
/// - `cyclo` must be the cyclotomic polynomial of degree `N` => x^N + 1

// N and Q Parameters of the BFV encryption scheme chosen according to TABLES of RECOMMENDED PARAMETERS for 128-bits security level
// https://homomorphicencryption.org/wp-content/uploads/2018/11/HomomorphicEncryptionStandardv1.1.pdf
// B is the upper bound of the distribution Chi Error. We pick standard deviation ùúé ‚âà 3.2 according to the HomomorphicEncryptionStandardv1 paper.
// T has been picked according to Lattigo (https://github.com/tuneinsight/lattigo/blob/master/bfv/params.go) implementation
// As suggest by https://eprint.iacr.org/2021/204.pdf (paragraph 2) we take B = 6œÉerr
const N: u64 = 1024;
const Q: u64 = (1 << 29) - 3;
const T: u64 = 65537;
const B: u64 = 18;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CircuitInput<const N: u64, const Q: u64, const T: u64, const B: u64> {
    pub pk0: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Should live in R_q (to be checked outside the circuit)
    pub pk1: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Should live in R_q (to be checked outside the circuit)
    pub m: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Should in R_t (checked inside the circuit)
    pub u: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Lives in R_q (checked inside the circuit)
    pub e0: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Lives in R_q (checked inside the circuit)
    pub e1: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Lives in R_q (checked inside the circuit)
    pub c0: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. It is compared to the ciphertext c0 generated by the circuit
    pub c1: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. It is compared to the ciphertext c1 generated by the circuit
}

fn bfv_encryption_circuit<F: ScalarField>(
    ctx: &mut Context<F>,
    input: CircuitInput<N, Q, T, B>,
    make_public: &mut Vec<AssignedValue<F>>,
) {
    // assert that the input polynomials have the same degree and this is equal to N - 1
    assert_eq!(input.pk0.len(), N as usize);
    assert_eq!(input.pk1.len(), N as usize);
    assert_eq!(input.m.len(), N as usize);
    assert_eq!(input.u.len(), N as usize);
    assert_eq!(input.e0.len(), N as usize);
    assert_eq!(input.e1.len(), N as usize);
    assert_eq!(input.c0.len(), N as usize);
    assert_eq!(input.c1.len(), N as usize);

    let mut pk0 = vec![];
    let mut pk1 = vec![];
    let mut u = vec![];
    let mut m = vec![];
    let mut e0 = vec![];
    let mut e1 = vec![];

    // Assign the input polynomials to the circuit
    // Using a for loop from 0 to N - 1 enforces that the assigned input polynomials have the same degree and this is equal to N - 1
    for i in 0..N as usize {
        let pk0_val = F::from(input.pk0[i]);
        let pk1_val = F::from(input.pk1[i]);
        let u_val = F::from(input.u[i]);
        let m_val = F::from(input.m[i]);
        let e0_val = F::from(input.e0[i]);
        let e1_val = F::from(input.e1[i]);

        let pk0_assigned_value = ctx.load_witness(pk0_val);
        let pk1_assigned_value = ctx.load_witness(pk1_val);
        let u_assigned_value = ctx.load_witness(u_val);
        let m_assigned_value = ctx.load_witness(m_val);
        let e0_assigned_value = ctx.load_witness(e0_val);
        let e1_assigned_value = ctx.load_witness(e1_val);

        pk0.push(pk0_assigned_value);
        pk1.push(pk1_assigned_value);
        u.push(u_assigned_value);
        m.push(m_assigned_value);
        e0.push(e0_assigned_value);
        e1.push(e1_assigned_value);
    }

    assert!(pk0.len() == N as usize);
    assert!(pk1.len() == N as usize);
    assert!(u.len() == N as usize);
    assert!(m.len() == N as usize);
    assert!(e0.len() == N as usize);
    assert!(e1.len() == N as usize);

    const DELTA: u64 = Q / T; // Q/T rounded to the lower integer

    // lookup bits must agree with the size of the lookup table, which is specified by an environmental variable
    let lookup_bits = var("LOOKUP_BITS")
        .unwrap_or_else(|_| panic!("LOOKUP_BITS not set"))
        .parse()
        .unwrap();

    let range = RangeChip::default(lookup_bits);

    // TO DO: Assign cyclotomic polynomial `cyclo` to the circuit

    /* Constraints on e0
        - e0 must be a polynomial in the R_q ring => Coefficients must be in the [0, Q) range and the degree of e0 must be N - 1
        - e0 must be sampled from the distribution ChiError

        Approach:
        - `check_poly_from_distribution_chi_error` chip guarantees that the coefficients of e0 are in the range [0, b] OR [q-b, q-1]
        - As this range is a subset of the [0, Q) range, the coefficients of e0 are in the [0, Q) range
        - The assignment for loop above guarantees that the degree of e0 is N - 1
    */

    /* Constraints on e1
        Same as e0
    */

    check_poly_from_distribution_chi_error::<{ N - 1 }, Q, B, F>(ctx, e0, &range);
    check_poly_from_distribution_chi_error::<{ N - 1 }, Q, B, F>(ctx, e1, &range);

    /* Constraints on u
        - u must be a polynomial in the R_q ring => Coefficients must be in the [0, Q) range and the degree of u must be N - 1
        - u must be sampled from the distribution ChiKey

        Approach:
        - `check_poly_from_distribution_chi_key` chip guarantees that the coefficients of u are in the range [0, 1, Q-1]
        - As this range is a subset of the [0, Q) range, the coefficients of u are in the [0, Q) range
        - The assignment for loop above guarantees that the degree of u is N - 1
    */

    check_poly_from_distribution_chi_key::<{ N - 1 }, Q, F>(ctx, u, range.gate());

    /* Constraints on m
        - m must be a polynomial in the R_t ring => Coefficients must be in the [0, T) range and the degree of m must be N - 1

        Approach:
        - `reduce_poly_mod` takes as input a polynomial and a modulus and returns the polynomial reduced by the modulus.
        The constraint set is that the input polynomial is equal to the output polynomial meaning that the coefficients of the input polynomial
        were already in the [0, T) range
        - The assignment for loop above guarantees that the degree of m is N - 1
    */

    // 1. COMPUTE C0

    // pk0 * u

    // TO DO: Perform the polynomial multiplication between pk0 and u.
    // TO DO: Reduce the resulting polynomial by the cyclotomic polynomial of degree `N` => x^N + 1
    // TO DO: Further reduce the coefficients by modulo `Q`

    // OVERFLOW ANALYSIS
    // The coefficients of pk0 are in the range [0, Q) according to the check to be performed outside the circuit.
    // The coefficients of u are either [0, 1, Q-1] according to the constraints set above.
    // The maximum value of the coffiecient of pk0_u is (Q-1) * (Q-1) = Q^2 - 2Q + 1.
    // Q needs to be chosen such that Q^2 - 2Q + 1 < p where p is the prime field of the circuit in order to avoid overflow during the multiplication.

    // let pk0_u = poly_mul::<{ N - 1 }, F>(ctx, pk0, u.clone(), &gate);
    // Note: pk0_u is a polynomial in the R_q ring

    // m * delta

    // TO DO: Perform the polynomial scalar multiplication between m and delta.
    // TO DO: Reduce the coefficients by modulo `Q`
    // Note: Scalar multiplication does not change the degree of the polynomial, therefore we do not need to reduce the coefficients by the cyclotomic polynomial of degree `N` => x^N + 1

    // OVERFLOW ANALYSIS
    // The coefficients of m are in the range [0, T) according to the constaints set above.
    // Delta is a constant in the range [0, Q) as it is defined as Q/T rounded to the lower integer and T < Q and T > 1.
    // The maximum value of the coffiecient of m_delta is (Q-1) * (T-1) = QT - Q - T + 1.
    // T has to be less than Q (check performed outside the circuit).
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the scalar multiplication.

    // DEGREE ANALYSIS
    // let m_delta = poly_scalar_mul::<{ N - 1 }, F>(ctx, m, Constant(F::from(DELTA)), &gate);
    // Note: m_delta is a polynomial in the R_q ring

    // pk0_u + m_delta

    // TO DO: Perform the polynomial addition between pk0_u and m_delta.
    // TO DO: Reduce the coefficients by modulo `Q`
    // Note: Addition does not change the degree of the polynomial, therefore we do not need to reduce the coefficients by the cyclotomic polynomial of degree `N` => x^N + 1

    // OVERFLOW ANALYSIS
    // The coefficients of pk0_u and m_delta are in the [0, Q) range according to the constraints set above.
    // The maximum value of the coffiecient of pk0_u_plus_m_delta is (Q-1) + (Q-1) = 2Q - 2.
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the addition.

    // let pk0_u_plus_m_delta = poly_add::<N, F>(ctx, pk0_u, m_delta, &gate);
    // Note: pk0_u_plus_m_delta is a polynomial in the R_q ring

    // c0 = pk0_u_plus_m_delta + e0

    // TO DO: Perform the polynomial addition between pk0_u_plus_m_delta and e0.
    // TO DO: Reduce the coefficients by modulo `Q`
    // Note: Addition does not change the degree of the polynomial, therefore we do not need to reduce the coefficients by the cyclotomic polynomial of degree `N` => x^N + 1

    // OVERFLOW ANALYSIS
    // The coefficients of pk0_u_plus_m_delta are in the [0, Q) range according to the constraints set above.
    // The coefficients of e0 are in the range [0, b] OR [q-b, q-1] according to the constraints set above.
    // The maximum value of the coffiecient of c0 is (Q-1) + (Q-1) = 2Q - 2.
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the addition.

    // let c0 = poly_add::<N, F>(ctx, pk0_u_plus_m_delta, e0, &gate);
    // Note: c0 is a polynomial in the R_q ring

    // 1. COMPUTE C1

    // pk1 * u

    // TO DO: Perform the polynomial multiplication between pk1 and u.
    // TO DO: Reduce the resulting polynomial by the cyclotomic polynomial of degree `N` => x^N + 1
    // TO DO: Further reduce the coefficients by modulo `Q`

    // OVERFLOW ANALYSIS
    // The coefficients of pk1 are in the range [0, Q) according to the check to be performed outside the circuit.
    // The coefficients of u are either [0, 1, Q-1] according to the constraints set above.
    // The maximum value of the coffiecient of pk0_u is (Q-1) * (Q-1) = Q^2 - 2Q + 1.
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the multiplication.

    // let pk1_u = poly_mul::<{ N - 1 }, F>(ctx, pk1, u.clone(), &gate);
    // Note: pk1_u is a polynomial in the R_q ring

    // TO DO: perform pk1_u + e1 to get c1

    // TO DO: Perform the polynomial addition between pk1_u and e1.
    // TO DO: Reduce the coefficients by modulo `Q`
    // Note: Addition does not change the degree of the polynomial, therefore we do not need to reduce the coefficients by the cyclotomic polynomial of degree `N` => x^N + 1

    // OVERFLOW ANALYSIS
    // The coefficients of pk1_u are in the [0, Q) range according to the constraints set above.
    // The coefficients of e1 are in the range [0, b] OR [q-b, q-1] according to the constraints set above.
    // The maximum value of the coffiecient of c1 is (Q-1) + (Q-1) = 2Q - 2.
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the addition.

    // let c1 = poly_add::<N, F>(ctx, pk1_u, e1, &gate);
    // Note: c1 is a polynomial in the R_q ring

    // TO DO: Expose to the public the coefficients of c0 and c1
    // TO DO: Expose to the public pk0 and pk1
    // TO DO: Expose to the public `cyclo`

    // TO DO: test that c0 and c1 computed inside the circuit are equal to the ciphertexts provided as input in the json file
}

fn main() {
    env_logger::init();

    let args = Cli::parse();

    run(bfv_encryption_circuit, args);
}
