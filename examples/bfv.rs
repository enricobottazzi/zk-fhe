use std::env::var;
use std::vec;

use clap::Parser;
use halo2_base::gates::GateChip;
use halo2_base::safe_types::RangeChip;
use halo2_base::safe_types::RangeInstructions;
use halo2_base::utils::ScalarField;
use halo2_base::AssignedValue;
use halo2_base::Context;
use halo2_base::QuantumCell::Constant;
use halo2_scaffold::scaffold::cmd::Cli;
use halo2_scaffold::scaffold::run;
use serde::{Deserialize, Serialize};
use zk_fhe::chips::poly_distribution::{
    check_poly_from_distribution_chi_error, check_poly_from_distribution_chi_key,
};
use zk_fhe::chips::poly_operations::{poly_add, poly_mul_equal_deg, poly_scalar_mul};

/// Circuit inputs for BFV encryption operations
///
/// # Type Parameters
///
/// * `N`: Degree of the cyclotomic polynomial `cyclo` of the polynomial ring R_q.
/// * `Q`: Modulus of the cipher text field
/// * `T`: Modulus of the plaintext field
/// * `DELTA` : Q/T rounded to the lower integer
/// * `B`: Upper bound of the Gaussian distribution Chi Error. It is defined as 6 * sigma
///
/// # Fields
///
/// * `pk0`: Public key 0 polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i
/// * `pk1`: Public key 1 polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i
/// * `m`: Plaintext polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Represents the message to be encrypted
/// * `u`: Ephemeral key polynomial coefficients from the distribution ChiKey [a_0, a_1, ..., a_N-1]
/// * `e0`: Error polynomial coefficients from the distribution ChiError [a_0, a_1, ..., a_N-1]
/// * `e1`: Error polynomial coefficients from the distribution ChiError [a_0, a_1, ..., a_N-1]

///
/// # Assumes that the following checks have been performed outside the circuit
/// - `N` must be a power of 2
/// - `Q` must be a prime number
/// - `Q` must be greater than 1.
/// -  If n is the number of bits of Q, and m is the number of bits of the prime field of the circuit. n must be set such that (n * 2) + 2 < m to avoid overflow of the coefficients of the polynomials
/// - `T` must be a prime number and must be greater than 1 and less than `Q`
/// - `B` must be a positive integer
/// - `pk0` and `pk1` must be polynomials in the R_q ring. The ring R_q is defined as R_q = Z_q[x]/(x^N + 1)
/// - `cyclo` must be the cyclotomic polynomial of degree `N` => x^N + 1

// N and Q Parameters of the BFV encryption scheme chosen according to TABLES of RECOMMENDED PARAMETERS for 128-bits security level
// https://homomorphicencryption.org/wp-content/uploads/2018/11/HomomorphicEncryptionStandardv1.1.pdf
// B is the upper bound of the distribution Chi Error. We pick standard deviation ùúé ‚âà 3.2 according to the HomomorphicEncryptionStandardv1 paper.
// T has been picked according to Lattigo (https://github.com/tuneinsight/lattigo/blob/master/bfv/params.go) implementation
// As suggest by https://eprint.iacr.org/2021/204.pdf (paragraph 2) we take B = 6œÉerr
const N: u64 = 1024;
const Q: u64 = (1 << 29) - 3;
const T: u64 = 65537;
const B: u64 = 18;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CircuitInput<const N: u64, const Q: u64, const T: u64, const B: u64> {
    pub pk0: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Should live in R_q (to be checked outside the circuit)
    pub pk1: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Should live in R_q (to be checked outside the circuit)
    pub m: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Should in R_t (checked inside the circuit)
    pub u: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Lives in R_q (checked inside the circuit)
    pub e0: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Lives in R_q (checked inside the circuit)
    pub e1: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. Lives in R_q (checked inside the circuit)
    pub c0: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. It is compared to the ciphertext c0 generated by the circuit
    pub c1: Vec<u64>, // polynomial coefficients [a_0, a_1, ..., a_N-1] where a_i is the coefficient of x^i. It is compared to the ciphertext c1 generated by the circuit
}

fn bfv_encryption_circuit<F: ScalarField>(
    ctx: &mut Context<F>,
    input: CircuitInput<N, Q, T, B>,
    make_public: &mut Vec<AssignedValue<F>>,
) {
    // assert that the input polynomials have the same degree and this is equal to N - 1
    assert_eq!(input.pk0.len(), N as usize);
    assert_eq!(input.pk1.len(), N as usize);
    assert_eq!(input.m.len(), N as usize);
    assert_eq!(input.u.len(), N as usize);
    assert_eq!(input.e0.len(), N as usize);
    assert_eq!(input.e1.len(), N as usize);
    assert_eq!(input.c0.len(), N as usize);
    assert_eq!(input.c1.len(), N as usize);

    let mut pk0 = vec![];
    let mut pk1 = vec![];
    let mut u = vec![];
    let mut m = vec![];
    let mut e0 = vec![];
    let mut e1 = vec![];

    // Assign the input polynomials to the circuit
    // Using a for loop from 0 to N - 1 enforces that the assigned input polynomials have the same degree and this is equal to N - 1
    for i in 0..N as usize {
        let pk0_val = F::from(input.pk0[i]);
        let pk1_val = F::from(input.pk1[i]);
        let u_val = F::from(input.u[i]);
        let m_val = F::from(input.m[i]);
        let e0_val = F::from(input.e0[i]);
        let e1_val = F::from(input.e1[i]);

        let pk0_assigned_value = ctx.load_witness(pk0_val);
        let pk1_assigned_value = ctx.load_witness(pk1_val);
        let u_assigned_value = ctx.load_witness(u_val);
        let m_assigned_value = ctx.load_witness(m_val);
        let e0_assigned_value = ctx.load_witness(e0_val);
        let e1_assigned_value = ctx.load_witness(e1_val);

        pk0.push(pk0_assigned_value);
        pk1.push(pk1_assigned_value);
        u.push(u_assigned_value);
        m.push(m_assigned_value);
        e0.push(e0_assigned_value);
        e1.push(e1_assigned_value);
    }

    assert!(pk0.len() == N as usize);
    assert!(pk1.len() == N as usize);
    assert!(u.len() == N as usize);
    assert!(m.len() == N as usize);
    assert!(e0.len() == N as usize);
    assert!(e1.len() == N as usize);

    const DELTA: u64 = Q / T; // Q/T rounded to the lower integer

    // lookup bits must agree with the size of the lookup table, which is specified by an environmental variable
    let lookup_bits = var("LOOKUP_BITS")
        .unwrap_or_else(|_| panic!("LOOKUP_BITS not set"))
        .parse()
        .unwrap();

    let range = RangeChip::default(lookup_bits);

    // TO DO: Assign cyclotomic polynomial `cyclo` to the circuit

    /* Constraints on e0
        - e0 must be a polynomial in the R_q ring => Coefficients must be in the [0, Q) range and the degree of e0 must be N - 1
        - e0 must be sampled from the distribution ChiError

        Approach:
        - `check_poly_from_distribution_chi_error` chip guarantees that the coefficients of e0 are in the range [0, b] OR [q-b, q-1]
        - As this range is a subset of the [0, Q) range, the coefficients of e0 are in the [0, Q) range
        - The assignment for loop above guarantees that the degree of e0 is N - 1
    */

    /* Constraints on e1
        Same as e0
    */

    check_poly_from_distribution_chi_error::<{ N - 1 }, Q, B, F>(ctx, e0, &range);
    check_poly_from_distribution_chi_error::<{ N - 1 }, Q, B, F>(ctx, e1, &range);

    /* Constraints on u
        - u must be a polynomial in the R_q ring => Coefficients must be in the [0, Q) range and the degree of u must be N - 1
        - u must be sampled from the distribution ChiKey

        Approach:
        - `check_poly_from_distribution_chi_key` chip guarantees that the coefficients of u are in the range [0, 1, Q-1]
        - As this range is a subset of the [0, Q) range, the coefficients of u are in the [0, Q) range
        - The assignment for loop above guarantees that the degree of u is N - 1
    */

    check_poly_from_distribution_chi_key::<{ N - 1 }, Q, F>(ctx, u.clone(), range.gate());

    /* Constraints on m
        - m must be a polynomial in the R_t ring => Coefficients must be in the [0, T) range and the degree of m must be N - 1

        Approach:
        - Perform a range check on the coefficients of m to be in the [0, T) range
        - The assignment for loop above guarantees that the degree of m is N - 1
    */

    // 1. COMPUTE C0

    // pk0 * u

    // TO DO: Perform the polynomial multiplication between pk0 and u.
    // TO DO: Reduce the resulting polynomial by the cyclotomic polynomial of degree `N` => x^N + 1
    // TO DO: Further reduce the coefficients by modulo `Q`

    // OVERFLOW ANALYSIS
    // The coefficients of pk0 are in the range [0, Q) according to the check to be performed outside the circuit.
    // The coefficients of u are either [0, 1, Q-1] according to the constraints set above.
    // The maximum value of the coffiecient of pk0_u is (Q-1) * (Q-1) = Q^2 - 2Q + 1.
    // Q needs to be chosen such that Q^2 - 2Q + 1 < p where p is the prime field of the circuit in order to avoid overflow during the multiplication.

    let pk0_u = poly_mul_equal_deg::<{ N - 1 }, F>(ctx, pk0, u, &range.gate());
    // Note: pk0_u is a polynomial in the R_q ring

    // m * delta

    // TO DO: Perform the polynomial scalar multiplication between m and delta.
    // TO DO: Reduce the coefficients by modulo `Q`
    // Note: Scalar multiplication does not change the degree of the polynomial, therefore we do not need to reduce the coefficients by the cyclotomic polynomial of degree `N` => x^N + 1

    // OVERFLOW ANALYSIS
    // The coefficients of m are in the range [0, T) according to the constaints set above.
    // Delta is a constant in the range [0, Q) as it is defined as Q/T rounded to the lower integer and T < Q and T > 1.
    // The maximum value of the coffiecient of m_delta is (Q-1) * (T-1) = QT - Q - T + 1.
    // T has to be less than Q (check performed outside the circuit).
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the scalar multiplication.

    // DEGREE ANALYSIS
    // let m_delta = poly_scalar_mul::<{ N - 1 }, F>(ctx, m, Constant(F::from(DELTA)), &gate);
    // Note: m_delta is a polynomial in the R_q ring

    // pk0_u + m_delta

    // TO DO: Perform the polynomial addition between pk0_u and m_delta.
    // TO DO: Reduce the coefficients by modulo `Q`
    // Note: Addition does not change the degree of the polynomial, therefore we do not need to reduce the coefficients by the cyclotomic polynomial of degree `N` => x^N + 1

    // OVERFLOW ANALYSIS
    // The coefficients of pk0_u and m_delta are in the [0, Q) range according to the constraints set above.
    // The maximum value of the coffiecient of pk0_u_plus_m_delta is (Q-1) + (Q-1) = 2Q - 2.
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the addition.

    // let pk0_u_plus_m_delta = poly_add::<N, F>(ctx, pk0_u, m_delta, &gate);
    // Note: pk0_u_plus_m_delta is a polynomial in the R_q ring

    // c0 = pk0_u_plus_m_delta + e0

    // TO DO: Perform the polynomial addition between pk0_u_plus_m_delta and e0.
    // TO DO: Reduce the coefficients by modulo `Q`
    // Note: Addition does not change the degree of the polynomial, therefore we do not need to reduce the coefficients by the cyclotomic polynomial of degree `N` => x^N + 1

    // OVERFLOW ANALYSIS
    // The coefficients of pk0_u_plus_m_delta are in the [0, Q) range according to the constraints set above.
    // The coefficients of e0 are in the range [0, b] OR [q-b, q-1] according to the constraints set above.
    // The maximum value of the coffiecient of c0 is (Q-1) + (Q-1) = 2Q - 2.
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the addition.

    // let c0 = poly_add::<N, F>(ctx, pk0_u_plus_m_delta, e0, &gate);
    // Note: c0 is a polynomial in the R_q ring

    // 1. COMPUTE C1

    // pk1 * u

    // TO DO: Perform the polynomial multiplication between pk1 and u.
    // TO DO: Reduce the resulting polynomial by the cyclotomic polynomial of degree `N` => x^N + 1
    // TO DO: Further reduce the coefficients by modulo `Q`

    // OVERFLOW ANALYSIS
    // The coefficients of pk1 are in the range [0, Q) according to the check to be performed outside the circuit.
    // The coefficients of u are either [0, 1, Q-1] according to the constraints set above.
    // The maximum value of the coffiecient of pk0_u is (Q-1) * (Q-1) = Q^2 - 2Q + 1.
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the multiplication.

    // let pk1_u = poly_mul::<{ N - 1 }, F>(ctx, pk1, u.clone(), &gate);
    // Note: pk1_u is a polynomial in the R_q ring

    // TO DO: perform pk1_u + e1 to get c1

    // TO DO: Perform the polynomial addition between pk1_u and e1.
    // TO DO: Reduce the coefficients by modulo `Q`
    // Note: Addition does not change the degree of the polynomial, therefore we do not need to reduce the coefficients by the cyclotomic polynomial of degree `N` => x^N + 1

    // OVERFLOW ANALYSIS
    // The coefficients of pk1_u are in the [0, Q) range according to the constraints set above.
    // The coefficients of e1 are in the range [0, b] OR [q-b, q-1] according to the constraints set above.
    // The maximum value of the coffiecient of c1 is (Q-1) + (Q-1) = 2Q - 2.
    // If the previous condition (Q^2 - 2Q + 1 < p) is satisfied there is no risk of overflow during the addition.

    // let c1 = poly_add::<N, F>(ctx, pk1_u, e1, &gate);
    // Note: c1 is a polynomial in the R_q ring

    // TO DO: Expose to the public the coefficients of c0 and c1
    // TO DO: Expose to the public pk0 and pk1
    // TO DO: Expose to the public `cyclo`

    // TO DO: test that c0 and c1 computed inside the circuit are equal to the ciphertexts provided as input in the json file
}

fn main() {
    env_logger::init();

    let args = Cli::parse();

    run(bfv_encryption_circuit, args);
}
